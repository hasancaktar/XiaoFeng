using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using XiaoFeng.Expressions;

namespace XiaoFeng
{
    /// <summary>
    /// 扩展拼接Lambda表达式树
    /// </summary>
    public static partial class PrototypeHelper
    {
        #region 扩展与条件表达式树
        /// <summary>
        /// 扩展与条件表达式树
        /// </summary>
        /// <typeparam name="T">类型</typeparam>
        /// <param name="first">当前表达式树</param>
        /// <param name="second">与的表达式树</param>
        /// <returns></returns>
        public static Expression<Func<T, bool>> And<T>(this Expression<Func<T, bool>> first, Expression<Func<T, bool>> second)
        {
            if (first == null) return second;
            if (second == null) return first;
            return Expression.Lambda<Func<T, bool>>(Expression.AndAlso(first.Body, second.Body), first.Parameters);
        }
        /// <summary>
        /// 扩展与条件表达式树
        /// </summary>
        /// <typeparam name="T">类型</typeparam>
        /// <param name="first">对象</param>
        /// <param name="propertyName">属性名</param>
        /// <param name="expressionType">表达式类型</param>
        /// <param name="value">值</param>
        /// <returns></returns>
        public static Expression<Func<T, bool>> And<T>(this Expression<Func<T, bool>> first, ExpressionType expressionType, string propertyName, object value)
        {
            if (first == null || propertyName.IsNullOrEmpty()) return first;
            var member = Expression.PropertyOrField(first.Parameters[0], propertyName);

            var val = Expression.Constant(value, member.Type);

            var body = Expression.MakeBinary(expressionType, member, val);
            body = Expression.AndAlso(first.Body, body);
            return Expression.Lambda<Func<T, bool>>(body, first.Parameters);
        }
        /// <summary>
        /// 扩展与条件表达式树
        /// </summary>
        /// <typeparam name="T">类型</typeparam>
        /// <param name="first">对象</param>
        /// <param name="propertyName">属性名</param>
        /// <param name="method">方法</param>
        /// <param name="value">值</param>
        /// <returns></returns>
        public static Expression<Func<T, bool>> And<T>(this Expression<Func<T, bool>> first, MethodInfo method, string propertyName, params object[] value)
        {
            if (first == null || method == null || propertyName.IsNullOrEmpty()) return first;
            var body = Expression.AndAlso(first.Body, first.Method(method, propertyName, value));
            return Expression.Lambda<Func<T, bool>>(body, first.Parameters);
        }
        #endregion

        #region 扩展或条件表达式树
        /// <summary>
        /// 扩展或条件表达式树
        /// </summary>
        /// <typeparam name="T">类型</typeparam>
        /// <param name="first">当前表达式树</param>
        /// <param name="second">或的表达式树</param>
        /// <returns></returns>
        public static Expression<Func<T, bool>> Or<T>(this Expression<Func<T, bool>> first, Expression<Func<T, bool>> second)
        {
            if (first == null) return second;
            if (second == null) return first;
            return Expression.Lambda<Func<T, bool>>(Expression.OrElse(first.Body, second.Body), first.Parameters);
        }
        /// <summary>
        /// 扩展与条件表达式树
        /// </summary>
        /// <typeparam name="T">类型</typeparam>
        /// <param name="first">对象</param>
        /// <param name="propertyName">属性名</param>
        /// <param name="method">表达式类型</param>
        /// <param name="value">值</param>
        /// <returns></returns>
        public static Expression<Func<T, bool>> Or<T>(this Expression<Func<T, bool>> first, MethodInfo method, string propertyName, params object[] value)
        {
            if (first == null || method == null || propertyName.IsNullOrEmpty()) return first;
            var body = Expression.OrElse(first.Body, first.Method(method, propertyName, value));
            return Expression.Lambda<Func<T, bool>>(body, first.Parameters);
        }
        #endregion

        #region 扩展包含表达式树
        /// <summary>
        /// 扩展包含表达式树
        /// </summary>
        /// <typeparam name="T">类型</typeparam>
        /// <param name="first">对象</param>
        /// <param name="propertyName">属性名</param>
        /// <param name="value">值</param>
        /// <returns></returns>
        public static Expression<Func<T, bool>> Contains<T>(this Expression<Func<T, bool>> first, string propertyName, object value)
        {
            var method = typeof(string).GetMethod("Contains", new[] { typeof(string) });
            return first.Method(method, propertyName, value);
        }
        #endregion

        #region 扩展不包含表达式树
        /// <summary>
        /// 扩展包含表达式树
        /// </summary>
        /// <typeparam name="T">类型</typeparam>
        /// <param name="first">对象</param>
        /// <param name="propertyName">属性名</param>
        /// <param name="value">值</param>
        /// <returns></returns>
        public static Expression<Func<T, bool>> NotContains<T>(this Expression<Func<T, bool>> first, string propertyName, object value)
        {
            var method = typeof(string).GetMethod("Contains", new[] { typeof(string) });
            return first.NotMethod(method, propertyName, value);
        }
        #endregion

        #region 扩展方法表达式树
        /// <summary>
        /// 扩展方法表达式树
        /// </summary>
        /// <typeparam name="T">类型</typeparam>
        /// <param name="first">对象</param>
        /// <param name="method">方法</param>
        /// <param name="propertyName">属性名</param>
        /// <param name="value">值</param>
        /// <returns></returns>
        public static Expression<Func<T, bool>> Method<T>(this Expression<Func<T, bool>> first, MethodInfo method, string propertyName, object value)
        {
            var member = Expression.PropertyOrField(first.Parameters[0], propertyName);
            var val = Expression.Constant(value, member.Type);
            var body = Expression.Call(member, method, val);
            return Expression.Lambda<Func<T, bool>>(body, first.Parameters);
        }
        #endregion

        #region 扩展非方法表达式树
        /// <summary>
        /// 扩展非方法表达式树
        /// </summary>
        /// <typeparam name="T">类型</typeparam>
        /// <param name="first">对象</param>
        /// <param name="method">方法</param>
        /// <param name="propertyName">属性名</param>
        /// <param name="value">值</param>
        /// <returns></returns>
        public static Expression<Func<T, bool>> NotMethod<T>(this Expression<Func<T, bool>> first, MethodInfo method, string propertyName, object value)
        {
            var member = Expression.PropertyOrField(first.Parameters[0], propertyName);
            var val = Expression.Constant(value, member.Type);
            var body = Expression.Not(Expression.Call(member, method, val));
            return Expression.Lambda<Func<T, bool>>(body, first.Parameters);
        }
        #endregion

        /// <summary>
        /// 
        /// </summary>
        /// <param name="expression"></param>
        /// <param name="searchEx"></param>
        /// <param name="replaceEx"></param>
        /// <returns></returns>
        public static Expression Replace(this Expression expression, Expression searchEx, Expression replaceEx)
        {
            return new ReplaceVisitor(searchEx, replaceEx).Visit(expression);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <typeparam name="NewParam"></typeparam>
        /// <typeparam name="OldParam"></typeparam>
        /// <typeparam name="TResult"></typeparam>
        /// <param name="expression"></param>
        /// <returns></returns>
        public static Expression<Func<NewParam, TResult>> To<NewParam, OldParam, TResult>(this 
    Expression<Func<OldParam, TResult>> expression)
    where NewParam : OldParam
        {
            var param = Expression.Parameter(typeof(NewParam));
            return Expression.Lambda<Func<NewParam, TResult>>(
                expression.Body.Replace(expression.Parameters[0], param), param);
        }
        /// <summary>
        /// 获取编译数据
        /// </summary>
        /// <typeparam name="T">类型</typeparam>
        /// <param name="expression">表达式</param>
        /// <param name="paramName">参数名</param>
        /// <returns></returns>
        public static Func<T, bool> CompileGetValueExpression<T>(this Expression<Func<T, bool>> expression, string paramName = "a")
        {
            var propertyInfo = typeof(T);
            var instance = Expression.Parameter(propertyInfo, paramName);
            
            var lambda = Expression.Lambda<Func<T, bool>>(expression, instance);
            return lambda.Compile();
        }
    }
}